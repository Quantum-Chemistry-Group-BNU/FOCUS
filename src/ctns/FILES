
########
# CTNS #
########

Basic tasks:
 1. algebra -> <n|ctns>, <ctns1|ctns2>, <ctns1|H|ctns2>, etc.
 2. sampling -> |<n|ctns>|^2
 3. IO

Initialization:
 1. from SCI wavefunction
 2. variational optimization

Efficiency:
 1. use symmetry  
 2. parallelization

 
#########################
# V0: Relativistic CTNS #
#########################

Test
-------------------
 tests_ctns.h
 test_ctns.cpp  

Basics
-------------------
Dtype & Qsym:
 ctns_qkind.h -> kind of CTNS
 ctns_qsym.h -> quantum number class: qsym & qbond
Topology:
 ctns_topo.h  
 ctns_topo.cpp  

Initialization 
-------------------
 ctns_comb.h
 ctns_init.h -> init CTNS from SCI
 ctns_io.h
Schmidt decomposition:
 ctns_rbasis.h -> renorm_basis class 
 ctns_bipart.h 
 ctns_bipart.cpp => challenging part with TRS!
 ctns_kramers.h -> block matrix class
Qtensor:
 ctns_phys.h
 qtensor.h
 qtensor.h -> qtensor class
 qtensor2.h -> rwfuns
 qtensor3.h -> rsites
 qtensor_contract.h

Compute <I|J>,<n|CTNS>
-------------------
 ctns_ovlp.h -> basic algorithms

Compute <I|H|J>
-------------------
 ctns_oper.h -> operators
 oper_dict.h
 oper_io.h 
 oper_util.h
 oper_dot.h -> essential: dot op
 oper_renorm.h -> renormalization rules
 oper_compxwf.h -> essential: Oc*qt3
 oper_kernel.h -> for tensor operations
 oper_rbasis.h -> debug

Sweep algorithm: (1) onedot
---------------------------
 ctns_sweep.h
 sweep_data.h
 sweep_util.h
* local CI: Hdiag & Hx
 sweep_onedot.h => ED works!
* decimation & operator transformation
 ctns_dpt.h
 sweep_decimation.h
 qtensor_reshape.h
 sweep_renorm.h 
* guess
 sweep_guess.h
* perturbed density matrix
 sweep_prdm.h

Sweep algorithm: (2) TRS
---------------------------
* TRS-adapted decimation
 sweep_decimation.h
* TRS-adapted local CI
 sweep_dvdson.h

Sweep algorithm: (3) twodot
---------------------------
 sweep_twodot.h
* qt4: reshaping
 qtensor_rank4.h
 qtensor_reshape4.h
* Decimation
 sweep_twodot_decimation.h
* Davidson
 sweep_twodot_ham.h
* Guess
 sweep_twodot_guess.h

Sweep algorithm: (4) TRS
---------------------------
* qt4: K()
 qtensor_rank4.h
* diag & ham:
 sweep_twodot_ham.h


#######################
# V1: Parallelization # 
#######################

Operator related:
-------------------
 oper_combine.h
 oper_normxwf.h
 oper_compxwf.h
 oper_renorm.h
 oper_util.h
 oper_dot.h

Sweep related:
-------------------
 sweep_dvdson.h
 sweep_onedot.h
 sweep_onedot_renorm.h
 sweep_onedot_ham.h
 sweep_guess.h
 sweep_prdm.h
 sweep_twodot.h
 sweep_twodot_ham.h
 sweep_twodot_renorm.h


################################
# V2: Optimized data structure #
################################

Reorganized files:
-------------------------
Tests:
 tests_ctns.h
 test_ctns.cpp 
Symmetry:
 ctns_qkind.h -> kind of CTNS
 ctns_qsym.h -> quantum number class: qsym 
 ctns_qbond.h -> bond space
 ctns_qdpt.h
Topology:
 ctns_comb.h
 ctns_topo.h  
 ctns_topo.cpp  
Initialization: Schmidt decomposition
 ctns_init.h -> init CTNS from SCI
 init_rbasis.h -> renorm_basis class 
 init_phys.h
 init_bipart.h => challenging part with TRS!
Qtensor: [to be optimized]
 pdvdson.h
 kramers_ortho.h -> ortho_basis
 kramers_linalg.h -> decimation
 qtensor_rank2.h -> rwfuns
 qtensor_rank3.h -> rsites
 qtensor_rank4.h
 qtensor_reshape3.h
 qtensor_reshape4.h
 qtensor_contract.h
 qtensor_kramers.h
 pdvdson.h
 pdvdson_kramers.h
IO:
 ctns_io.h
Algorithms:
 ctns_alg.h -> basic algorithms for <I|J>,<n|CTNS>,sampling
Operators: [to be optimized]
 ctns_oper.h -> Hmat
 oper_util.h
 oper_dict.h
 oper_io.h
 oper_dot.h -> local operators
 oper_renorm.h -> <r|O|r'> [to be optimized] 
 oper_combine.h
 oper_normxwf.h
 oper_compxwf.h
 oper_kernel.h
 oper_timer.cpp
 oper_timer.h
 oper_rbasis.h -> debug
Sweep:
 ctns_sweep.h
 sweep_data.h
 sweep_onedot.h
 sweep_onedot_ham.h
 sweep_onedot_renorm.h
 sweep_twodot.h
 sweep_twodot_ham.h
 sweep_twodot_renorm.h
 sweep_ham.h
 sweep_decimation.h
 sweep_guess.h
 ctns_sys.h

#################################################################

Low-level data structure
-------------------------
 qtensor2 - operator / density matrix - o[l,r]
 qtensor3 - onedot wf[l,c,r] / site
 qtensor4 - twodot wf[l,c1,c2,r]->wf[lc1,c2,r],wf[l,c1,c2r]

KEY: storage pattern -> affect low-level contraction efficiency! => HOW???
     =, copy [same size -> just copy data -> no memory reallocation]

TODOs: Tensor operations
-------------------------
 1. allocate temporary work space!
 2. in place operation:
    opwf += oper_kernel_OOwf(superblock,site,op1c,op2S,1); 
 sweep_twodot_ham.h:
    // Apq*Ppq
    qt3n = oper_compxwf_opP("cr",wf2,c2qops,rqops,isym,ifkr,int2e,int1e,index);
    qt3n = qt3n.merge_cr().split_lc(wf.qrow,wf.qmid);
    auto Hwf1 = wt*oper_normxwf_opA("lc",qt3n,lqops,c1qops,ifkr,iformula,index);
 oper_normxwf.h:
 oper_compxwf.h:
    qtensor3<Tm> opwf(site.sym, site.qmid, site.qrow, site.qcol, site.dir); -> working space
    opwf += oper_kernel_OOwf(superblock,site,op1c,op2S,1); -> inplace
    opwf += wt*oper_kernel_OOwf(superblock,site,op1_A,op2_A,0);
 oper_kernel.h:
    oper_kernel_OIwf
    oper_kernel_IOwf
    oper_kernel_OOwf
 3. remove T() and H() in contract_qt_qt...

#################################################################

Symmetry:
 qnum_qkind.h -> kind of CTNS
 qnum_qsym.h -> quantum number class: qsym 
 qnum_qbond.h -> bond space
 qnum_qdpt.h
Tests:
 tests_ctns.h
 test_ctns.cpp 
Tensor: [to be optimized]
 tensor.h
 tensor_dense.h
 tensor_qinfo2.h
 tensor_qinfo3.h
 tensor_qinfo4.h
 tensor_sparse2.h -> rwfuns
 tensor_sparse3.h -> rsites
 tensor_sparse4.h
 tensor_linalg.h
 tensor_contract.h
Topology:
 ctns_comb.h
 ctns_topo.h  
 ctns_topo.cpp  
Kramers:
 kramers_ortho.h -> ortho_basis
 kramers_linalg.h -> decimation
Initialization: Schmidt decomposition
 ctns_init.h -> init CTNS from SCI
 init_rbasis.h -> renorm_basis class 
 init_phys.h
 init_bipart.h => challenging part with TRS!
IO:
 ctns_io.h
Algorithms:
 ctns_alg.h -> basic algorithms for <I|J>,<n|CTNS>,sampling
 alg_ova.h
Operators: [to be optimized]
 ctns_oper.h -> Hmat
 oper_env.h
 --- basic data structure ---
 oper_index.h 
 oper_dict.h -> KEY: design a good container for renormalized operators: 
		construction, IO, dot, renormalization, etc.
	        We can use a label to distinguish memory owner.
		qinfo2 -> qtensor()
 oper_dot.h -> local operators
 oper_io.h
 --- renormalization ---
 oper_timer.h -> timing for opxwf
 oper_timer.cpp
 
 oper_renorm.h -> <r|O|r'> [to be optimized]

 oper_normxwf.h
 oper_compxwf.h

 oper_kernel.h

 oper_rbasis.h -> for debugging renormalized operators

#################################################################

Qtensor: [to be optimized]
 qtensor_reshape3.h
 qtensor_reshape4.h
 qtensor_kramers.h
 pdvdson.h
 pdvdson_kramers.h

Sweep: [to be optimized]
 ctns_sweep.h
 sweep_data.h
 sweep_onedot.h
 sweep_onedot_ham.h
 sweep_onedot_renorm.h
 sweep_twodot.h
 sweep_twodot_ham.h
 sweep_twodot_renorm.h
 sweep_ham.h
 sweep_decimation.h
 sweep_guess.h
 ctns_sys.h

