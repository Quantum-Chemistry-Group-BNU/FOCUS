
# CTNS #

Basic tasks:
 1. algebra -> <n|ctns>, <ctns1|ctns2>, <ctns1|H|ctns2>, etc.
 2. sampling -> |<n|ctns>|^2
 3. IO

Initialization:
 1. from SCI wavefunction
 2. variational optimization

Efficiency:
 1. use symmetry  
 2. parallelization

 
# Description of files #


V0: Relativistic CTNS
=====================

Test
-------------------
 tests_ctns.h
 test_ctns.cpp  

Basics
-------------------
Topology:
 ctns_topo.h  
 ctns_topo.cpp  
Dtype & Qsym:
 ctns_kind.h -> kind of CTNS
 ctns_qsym.h -> quantum number class: qsym & qbond

Initialization 
-------------------
 ctns_comb.h
 ctns_init.h -> init CTNS from SCI
 ctns_io.h
Schmidt decomposition:
 ctns_rbasis.h -> renorm_basis class 
 ctns_bipart.h 
 ctns_bipart.cpp => challenging part with TRS!
 ctns_kramers.h -> block matrix class
Qtensor:
 ctns_phys.h
 qtensor.h
 qtensor.h -> qtensor class
 qtensor2.h -> rwfuns
 qtensor3.h -> rsites
 qtensor_contract.h

Compute <I|J>,<n|CTNS>
-------------------
 ctns_ovlp.h -> basic algorithms

Compute <I|H|J>
-------------------
 ctns_oper.h -> operators
 oper_dict.h
 oper_io.h 
 oper_util.h
 oper_dot.h -> essential: dot op
 oper_renorm.h -> renormalization rules
 oper_compxwf.h -> essential: Oc*qt3
 oper_kernel.h -> for tensor operations
 oper_rbasis.h -> debug

Sweep algorithm: (1) onedot
---------------------------
 ctns_sweep.h
 sweep_data.h
 sweep_util.h
* local CI: Hdiag & Hx
 sweep_onedot.h => ED works!
* decimation & operator transformation
 ctns_dpt.h
 sweep_decimation.h
 qtensor_reshape.h
 sweep_renorm.h 
* guess
 sweep_guess.h
* perturbed density matrix
 sweep_prdm.h

Sweep algorithm: (2) TRS
---------------------------
* TRS-adapted decimation
 sweep_decimation.h
* TRS-adapted local CI
 sweep_dvdson.h

Sweep algorithm: (3) twodot
---------------------------
 sweep_twodot.h
* qt4: reshaping
 qtensor_rank4.h
 qtensor_reshape4.h
* Decimation
 sweep_twodot_decimation.h
* Davidson
 sweep_twodot_ham.h
* Guess
 sweep_twodot_guess.h

Sweep algorithm: (4) TRS
---------------------------
* qt4: K()
 qtensor_rank4.h
* diag & ham:
 sweep_twodot_ham.h


V1: Parallelization & Opt
=========================

Parallelization
-------------------------
* operator related:
 oper_combine.h
 oper_normxwf.h
 oper_compxwf.h
 oper_renorm.h
 oper_util.h
 oper_dot.h

* sweep related:
 sweep_dvdson.h
 sweep_onedot.h
 sweep_onedot_renorm.h
 sweep_onedot_ham.h
 sweep_guess.h
 sweep_prdm.h
 sweep_twodot.h
 sweep_twodot_ham.h
 sweep_twodot_renorm.h

Low-level data structure
-------------------------
 qtensor2 - operator/density matrix
 qtensor3 - onedot wf
 qtensor4 - twodot wf

Tensor operations
-------------------------

realization of rZ2 and cZ2?

 1. allocate temporary work space!
 2. in place operation:
    opwf += oper_kernel_OOwf(superblock,site,op1c,op2S,1); 

 sweep_twodot_ham.h:
    // Apq*Ppq
    qt3n = oper_compxwf_opP("cr",wf2,c2qops,rqops,isym,ifkr,int2e,int1e,index);
    qt3n = qt3n.merge_cr().split_lc(wf.qrow,wf.qmid);
    auto Hwf1 = wt*oper_normxwf_opA("lc",qt3n,lqops,c1qops,ifkr,iformula,index);

 oper_normxwf.h:
 oper_compxwf.h:
    qtensor3<Tm> opwf(site.sym, site.qmid, site.qrow, site.qcol, site.dir); -> working space
    opwf += oper_kernel_OOwf(superblock,site,op1c,op2S,1); -> inplace
    opwf += wt*oper_kernel_OOwf(superblock,site,op1_A,op2_A,0);

 oper_kernel.h:
    oper_kernel_OIwf
    oper_kernel_IOwf
    oper_kernel_OOwf
 
