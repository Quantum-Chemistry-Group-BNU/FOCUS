
########
# CTNS #
########

Basic tasks:
 1. algebra -> <n|ctns>, <ctns1|ctns2>, <ctns1|H|ctns2>, etc.
 2. sampling -> |<n|ctns>|^2
 3. IO

Initialization:
 1. from SCI wavefunction
 2. variational optimization

Efficiency:
 1. use symmetry  
 2. parallelization

 
#########################
# V0: Relativistic CTNS #
#########################

Test
-------------------
 tests_ctns.h
 test_ctns.cpp  

Basics
-------------------
Dtype & Qsym:
 ctns_qkind.h -> kind of CTNS
 ctns_qsym.h -> quantum number class: qsym & qbond
Topology:
 ctns_topo.h  
 ctns_topo.cpp  

Initialization 
-------------------
 ctns_comb.h
 ctns_init.h -> init CTNS from SCI
 ctns_io.h
Schmidt decomposition:
 ctns_rbasis.h -> renorm_basis class 
 ctns_bipart.h 
 ctns_bipart.cpp => challenging part with TRS!
 ctns_kramers.h -> block matrix class
Qtensor:
 ctns_phys.h
 qtensor.h
 qtensor.h -> qtensor class
 qtensor2.h -> rwfuns
 qtensor3.h -> rsites
 qtensor_contract.h

Compute <I|J>,<n|CTNS>
-------------------
 ctns_ovlp.h -> basic algorithms

Compute <I|H|J>
-------------------
 ctns_oper.h -> operators
 oper_dict.h
 oper_io.h 
 oper_util.h
 oper_dot.h -> essential: dot op
 oper_renorm.h -> renormalization rules
 oper_compxwf.h -> essential: Oc*qt3
 oper_kernel.h -> for tensor operations
 oper_rbasis.h -> debug

Sweep algorithm: (1) onedot
---------------------------
 ctns_sweep.h
 sweep_data.h
 sweep_util.h
* local CI: Hdiag & Hx
 sweep_onedot.h => ED works!
* decimation & operator transformation
 ctns_dpt.h
 sweep_decimation.h
 qtensor_reshape.h
 sweep_renorm.h 
* guess
 sweep_guess.h
* perturbed density matrix
 sweep_prdm.h

Sweep algorithm: (2) TRS
---------------------------
* TRS-adapted decimation
 sweep_decimation.h
* TRS-adapted local CI
 sweep_dvdson.h

Sweep algorithm: (3) twodot
---------------------------
 sweep_twodot.h
* qt4: reshaping
 qtensor_rank4.h
 qtensor_reshape4.h
* Decimation
 sweep_twodot_decimation.h
* Davidson
 sweep_twodot_ham.h
* Guess
 sweep_twodot_guess.h

Sweep algorithm: (4) TRS
---------------------------
* qt4: K()
 qtensor_rank4.h
* diag & ham:
 sweep_twodot_ham.h


#######################
# V1: Parallelization # 
#######################

Operator related:
-------------------
 oper_combine.h
 oper_normxwf.h
 oper_compxwf.h
 oper_renorm.h
 oper_util.h
 oper_dot.h

Sweep related:
-------------------
 sweep_dvdson.h
 sweep_onedot.h
 sweep_onedot_renorm.h
 sweep_onedot_ham.h
 sweep_guess.h
 sweep_prdm.h
 sweep_twodot.h
 sweep_twodot_ham.h
 sweep_twodot_renorm.h


################################
# V2: Optimized data structure #
################################

Reorganized files
-----------------
Tests:
 tests_ctns.h
 test_ctns.cpp 
Symmetry:
 ctns_qkind.h -> kind of CTNS
 ctns_qsym.h -> quantum number class: qsym 
 ctns_qbond.h -> bond space
 ctns_qdpt.h
Topology:
 ctns_comb.h
 ctns_topo.h  
 ctns_topo.cpp  
Initialization: Schmidt decomposition
 ctns_init.h -> init CTNS from SCI
 init_rbasis.h -> renorm_basis class 
 init_phys.h
 init_bipart.h => challenging part with TRS!
Qtensor: [to be optimized]
 pdvdson.h
 kramers_ortho.h -> ortho_basis
 kramers_linalg.h -> decimation
 qtensor_rank2.h -> rwfuns
 qtensor_rank3.h -> rsites
 qtensor_rank4.h
 qtensor_reshape3.h
 qtensor_reshape4.h
 qtensor_contract.h
 qtensor_kramers.h
 pdvdson.h
 pdvdson_kramers.h
IO:
 ctns_io.h
Algorithms:
 ctns_alg.h -> basic algorithms for <I|J>,<n|CTNS>,sampling
Operators: [to be optimized]
 ctns_oper.h -> Hmat
 oper_util.h
 oper_dict.h
 oper_io.h
 oper_dot.h -> local operators
 oper_renorm.h -> <r|O|r'> [to be optimized] 
 oper_combine.h
 oper_normxwf.h
 oper_compxwf.h
 oper_kernel.h
 oper_timer.cpp
 oper_timer.h
 oper_rbasis.h -> debug
Sweep:
 ctns_sweep.h
 sweep_data.h
 sweep_onedot.h
 sweep_onedot_ham.h
 sweep_onedot_renorm.h
 sweep_twodot.h
 sweep_twodot_ham.h
 sweep_twodot_renorm.h
 sweep_ham.h
 sweep_decimation.h
 sweep_guess.h
 ctns_sys.h

Rewrite low-level data structure: qtensor & oper_dict
 qtensor2 - operator / density matrix - o[l,r]
 qtensor3 - onedot wf[l,c,r] / site
 qtensor4 - twodot wf[l,c1,c2,r] -> wf[lc1,c2,r],wf[l,c1,c2r]
KEY: storage pattern -> affect low-level contraction efficiency! HOW?
     =, copy [same size -> just copy data -> no memory reallocation]
-----------------------------------------------------
Symmetry:
 qtensor/qnum_qkind.h -> kind of CTNS
 qtensor/qnum_qsym.h -> quantum number class: qsym 
 qtensor/qnum_qbond.h -> bond space
 qtensor/qnum_qdpt.h
Tests:
 tests_ctns.h
 test_ctns.cpp 
Tensor: [to be optimized]
 qtensor/qtensor.h
 qtensor/tensor_dense.h
 qtensor/tensor_qinfo2.h
 qtensor/tensor_qinfo3.h
 qtensor/tensor_qinfo4.h
 qtensor/tensor_sparse2.h -> rwfuns
 qtensor/tensor_sparse3.h -> rsites
 qtensor/tensor_sparse4.h
 qtensor/tensor_linalg.h
 qtensor/tensor_contract.h
Topology:
 ctns_comb.h
 ctns_topo.h  
 ctns_topo.cpp  
Kramers:
 qtensor/kramers_ortho.h -> ortho_basis
 qtensor/kramers_linalg.h -> decimation
Initialization: Schmidt decomposition
 ctns_init.h -> init CTNS from SCI
 init_rbasis.h -> renorm_basis class 
 init_phys.h
 init_bipart.h => challenging part with TRS!
IO:
 ctns_io.h
Algorithms:
 ctns_alg.h -> basic algorithms for <I|J>,<n|CTNS>,sampling
 alg_ova.h
Operators: [to be optimized]
 ctns_oper.h -> Hmat
 oper_env.h
 --- basic data structure ---
 oper_index.h 
 oper_dict.h -> KEY: design a good container for renormalized operators: 
		construction, IO, dot, renormalization, etc.
	        We can use a label to distinguish memory owner.
		qinfo2 -> qtensor()
 oper_dot.h -> local operators
 oper_io.h
 --- renormalization ---
 oper_timer.h -> timing for opxwf
 oper_timer.cpp
 oper_renorm.h -> <r|O|r'> [to be optimized]
 oper_functors.h
 oper_rbasis.h -> for debugging renormalized operators
 --- time consuming part: kernel ---
 oper_normxwf.h 
 oper_compxwf.h
 oper_op1op2xwf.h 
 oper_kernel.h -> qtensor/tensor_contract.h 
Sweep optimization:
 ctns_sweep.h
 sweep_data.h
 --- onedot ---
 sweep_onedot.h
 qtensor/tensor_reshape3.h -> reshaping qt3 for decimation
 sweep_onedot_renorm.h
 sweep_decimation.h
 sweep_onedot_hdiag.h
 sweep_onedot_local.h
 qtensor/pdvdson.h
 sweep_onedot_sigma.h => costly part!
 --- twodot ---
 sweep_onedot.h
 qtensor/qtensor_reshape4.h
 sweep_twodot_renorm.h
 sweep_twodot_hdiag.h
 sweep_twodot_local.h
 sweep_twodot_sigma.h
 --- OpenMP version ---
 --- MPI version ---
 --- Kramers ---
 qtensor/kramers_ortho.h
 qtensor/tensor_sparse3.h
 qtensor/tensor_sparse4.h
 qtensor/pdvdson_kramers.h


############################
# V3: Optimized twodot H*x #
############################

Symbolic derivations: expansion of formulae:
 symbolic_oper.h
 symbolic_normxwf.h
 symbolic_compxwf.h
 symbolic_op1op2xwf.h
 symbolic_formulae_onedot.h
 symbolic_onedot_sigma.h
 symbolic_formulae_twodot.h
 symbolic_twodot_sigma.h

Kramers symmetry-adapted version:
 oper_normxwf.h - line79,88 in opA; line132,142 in opB;
 oper_compxwf.h - line220 in opS(); line366 in opH(); 
 oper_op1op2xwf.h - line76 in oper_op1op2xwf_kr(); 

Twodot implementation: work with qt4_qt2 without reshaping
 qtensor/tensor_contract2.h
 qtensor/tensor_contract3.h
 qtensor/tensor_contract4.h

Optimized version:
 symbolic_preprocess.h
 symbolic_onedot_sigma2.h

NEW STRUCTURE of symbolic codes:
 symbolic_oper.h
 symbolic_task.h
 symbolic_normxwf.h
 symbolic_compxwf.h
 symbolic_op1op2xwf.h
 symbolic_formulae_onedot.h
 symbolic_formulae_twodot.h
 symbolic_formulae_renorm.h
 symbolic_kernel_sigma.h  // raw version: symbolic formulae + dynamic allocation of memory
 symbolic_kernel_sigma2.h // symbolic formulae + preallocation of workspace 
 symbolic_kernel_sigma3.h // symbolic formulae (factorized) + preallocation of workspace
 symbolic_kernel_renorm.h
 symbolic_kernel_renorm2.h
 symbolic_kernel_sum.h
 symbolic_preprocess.h

Distributed CS:
 oper_dot.h
 oper_index.h
 symbolic_compxwf.h // opS and opH
 oper_renorm.h // Ham works
 symbolic_formulae_renorm.h // remove term with size = 0!
 oper_compxwf.h // revise opS and opH to support ifdist1 
 symbolic_formulae_twodot.h  
 sweep_twodot_sigma.h // add ifdist1

TODOs:
 symbolic_formulae_onedot.h
 
#################################################################

优化方向: onedot/twodot算法

 0. intel VTune for Fe4S4 test -> cost of single Hx for D=1000
 1. probably change to shared_ptr to share data instead of raw pointer & own?
 2. 异构计算 -> further accelerate contract_qt4_qt2?
 3. direct operating wf4 in sweep_twodot_sigma.h without temporary stensor3
    versus reshape wf4->wf3?

