
########
# CTNS #
########

Basic tasks:
 1. algebra -> <n|ctns>, <ctns1|ctns2>, <ctns1|H|ctns2>, etc.
 2. sampling -> |<n|ctns>|^2
 3. IO

Initialization:
 1. from SCI wavefunction
 2. variational optimization

Efficiency:
 1. use symmetry  
 2. parallelization

 
#########################
# V0: Relativistic CTNS #
#########################

Test
-------------------
 tests_ctns.h
 test_ctns.cpp  

Basics
-------------------
Dtype & Qsym:
 ctns_qkind.h -> kind of CTNS
 ctns_qsym.h -> quantum number class: qsym & qbond
Topology:
 ctns_topo.h  
 ctns_topo.cpp  

Initialization 
-------------------
 ctns_comb.h
 ctns_init.h -> init CTNS from SCI
 ctns_io.h
Schmidt decomposition:
 ctns_rbasis.h -> renorm_basis class 
 ctns_bipart.h 
 ctns_bipart.cpp => challenging part with TRS!
 ctns_kramers.h -> block matrix class
Qtensor:
 ctns_phys.h
 qtensor.h
 qtensor.h -> qtensor class
 qtensor2.h -> rwfuns
 qtensor3.h -> rsites
 qtensor_contract.h

Compute <I|J>,<n|CTNS>
-------------------
 ctns_ovlp.h -> basic algorithms

Compute <I|H|J>
-------------------
 ctns_oper.h -> operators
 oper_dict.h
 oper_io.h 
 oper_util.h
 oper_dot.h -> essential: dot op
 oper_renorm.h -> renormalization rules
 oper_compxwf.h -> essential: Oc*qt3
 oper_kernel.h -> for tensor operations
 oper_rbasis.h -> debug

Sweep algorithm: (1) onedot
---------------------------
 ctns_sweep.h
 sweep_data.h
 sweep_util.h
* local CI: Hdiag & Hx
 sweep_onedot.h => ED works!
* decimation & operator transformation
 ctns_dpt.h
 sweep_decimation.h
 qtensor_reshape.h
 sweep_renorm.h 
* guess
 sweep_guess.h
* perturbed density matrix
 sweep_prdm.h

Sweep algorithm: (2) TRS
---------------------------
* TRS-adapted decimation
 sweep_decimation.h
* TRS-adapted local CI
 sweep_dvdson.h

Sweep algorithm: (3) twodot
---------------------------
 sweep_twodot.h
* qt4: reshaping
 qtensor_rank4.h
 qtensor_reshape4.h
* Decimation
 sweep_twodot_decimation.h
* Davidson
 sweep_twodot_ham.h
* Guess
 sweep_twodot_guess.h

Sweep algorithm: (4) TRS
---------------------------
* qt4: K()
 qtensor_rank4.h
* diag & ham:
 sweep_twodot_ham.h


#######################
# V1: Parallelization # 
#######################

Operator related:
-------------------
 oper_combine.h
 oper_normxwf.h
 oper_compxwf.h
 oper_renorm.h
 oper_util.h
 oper_dot.h

Sweep related:
-------------------
 sweep_dvdson.h
 sweep_onedot.h
 sweep_onedot_renorm.h
 sweep_onedot_ham.h
 sweep_guess.h
 sweep_prdm.h
 sweep_twodot.h
 sweep_twodot_ham.h
 sweep_twodot_renorm.h


################################
# V2: Optimized data structure #
################################

Reorganized files
-----------------
Tests:
 tests_ctns.h
 test_ctns.cpp 
Symmetry:
 ctns_qkind.h -> kind of CTNS
 ctns_qsym.h -> quantum number class: qsym 
 ctns_qbond.h -> bond space
 ctns_qdpt.h
Topology:
 ctns_comb.h
 ctns_topo.h  
 ctns_topo.cpp  
Initialization: Schmidt decomposition
 ctns_init.h -> init CTNS from SCI
 init_rbasis.h -> renorm_basis class 
 init_phys.h
 init_bipart.h => challenging part with TRS!
Qtensor: [to be optimized]
 pdvdson.h
 kramers_ortho.h -> ortho_basis
 kramers_linalg.h -> decimation
 qtensor_rank2.h -> rwfuns
 qtensor_rank3.h -> rsites
 qtensor_rank4.h
 qtensor_reshape3.h
 qtensor_reshape4.h
 qtensor_contract.h
 qtensor_kramers.h
 pdvdson.h
 pdvdson_kramers.h
IO:
 ctns_io.h
Algorithms:
 ctns_alg.h -> basic algorithms for <I|J>,<n|CTNS>,sampling
Operators: [to be optimized]
 ctns_oper.h -> Hmat
 oper_util.h
 oper_dict.h
 oper_io.h
 oper_dot.h -> local operators
 oper_renorm.h -> <r|O|r'> [to be optimized] 
 oper_combine.h
 oper_normxwf.h
 oper_compxwf.h
 oper_kernel.h
 oper_timer.cpp
 oper_timer.h
 oper_rbasis.h -> debug
Sweep:
 ctns_sweep.h
 sweep_data.h
 sweep_onedot.h
 sweep_onedot_ham.h
 sweep_onedot_renorm.h
 sweep_twodot.h
 sweep_twodot_ham.h
 sweep_twodot_renorm.h
 sweep_ham.h
 sweep_decimation.h
 sweep_guess.h
 ctns_sys.h

Rewrite low-level data structure: qtensor & oper_dict
 qtensor2 - operator / density matrix - o[l,r]
 qtensor3 - onedot wf[l,c,r] / site
 qtensor4 - twodot wf[l,c1,c2,r] -> wf[lc1,c2,r],wf[l,c1,c2r]
KEY: storage pattern -> affect low-level contraction efficiency! HOW?
     =, copy [same size -> just copy data -> no memory reallocation]
-----------------------------------------------------
Symmetry:
 qtensor/qnum_qkind.h -> kind of CTNS
 qtensor/qnum_qsym.h -> quantum number class: qsym 
 qtensor/qnum_qbond.h -> bond space
 qtensor/qnum_qdpt.h
Tests:
 tests_ctns.h
 test_ctns.cpp 
Tensor: [to be optimized]
 qtensor/qtensor.h
 qtensor/tensor_dense.h
 qtensor/tensor_qinfo2.h
 qtensor/tensor_qinfo3.h
 qtensor/tensor_qinfo4.h
 qtensor/tensor_sparse2.h -> rwfuns
 qtensor/tensor_sparse3.h -> rsites
 qtensor/tensor_sparse4.h
 qtensor/tensor_linalg.h
 qtensor/tensor_contract.h
Topology:
 ctns_comb.h
 ctns_topo.h  
 ctns_topo.cpp  
Kramers:
 qtensor/kramers_ortho.h -> ortho_basis
 qtensor/kramers_linalg.h -> decimation
Initialization: Schmidt decomposition
 ctns_init.h -> init CTNS from SCI
 init_rbasis.h -> renorm_basis class 
 init_phys.h
 init_bipart.h => challenging part with TRS!
IO:
 ctns_io.h
Algorithms:
 ctns_alg.h -> basic algorithms for <I|J>,<n|CTNS>,sampling
 alg_ova.h
Operators: [to be optimized]
 ctns_oper.h -> Hmat
 oper_env.h
 --- basic data structure ---
 oper_index.h 
 oper_dict.h -> KEY: design a good container for renormalized operators: 
		construction, IO, dot, renormalization, etc.
	        We can use a label to distinguish memory owner.
		qinfo2 -> qtensor()
 oper_dot.h -> local operators
 oper_io.h
 --- renormalization ---
 oper_timer.h -> timing for opxwf
 oper_timer.cpp
 oper_renorm.h -> <r|O|r'> [to be optimized]
 oper_functors.h
 oper_rbasis.h -> for debugging renormalized operators
 --- time consuming part: kernel ---
 oper_normxwf.h 
 oper_compxwf.h
 oper_op1op2xwf.h 
 oper_kernel.h -> qtensor/tensor_contract.h 
Sweep optimization:
 ctns_sweep.h
 sweep_data.h
 --- onedot ---
 sweep_onedot.h
 qtensor/tensor_reshape3.h -> reshaping qt3 for decimation
 sweep_onedot_renorm.h
 sweep_decimation.h
 sweep_onedot_hdiag.h
 sweep_onedot_local.h
 qtensor/pdvdson.h
 sweep_onedot_sigma.h => costly part!
 --- twodot ---
 sweep_onedot.h
 qtensor/qtensor_reshape4.h
 sweep_twodot_renorm.h
 sweep_twodot_hdiag.h
 sweep_twodot_local.h
 sweep_twodot_sigma.h
 --- OpenMP version ---
 --- MPI version ---
 --- Kramers ---
 qtensor/kramers_ortho.h
 qtensor/tensor_sparse3.h
 qtensor/tensor_sparse4.h
 qtensor/pdvdson_kramers.h


############################
# V3: Optimized twodot H*x #
############################

Symbolic derivations: expansion of formulae
 symbolic_oper.h
 symbolic_normxwf.h
 symbolic_compxwf.h
 symbolic_op1op2xwf.h
 symbolic_onedot_formulae.h
 symbolic_onedot_sigma.h
 symbolic_twodot_formulae.h
 symbolic_twodot_sigma.h
Better twodot implementation: direct work with qt4_qt2 without reshaping



#################################################################

优化方向: twodot算法

 0. intel VTune for Fe4S4 test -> cost of single Hx for D=1000

    isweep=5 ibond=51 bond=(15,0)-(16,0) (dots,forward,cturn)=(2,0,0)
    ----------------------------------------------------------------------
    ctns::sweep_twodot
    support info:
     suppl= 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14
     suppr= 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35
     suppc1= 15
     suppc2= 16
    qops info: rank=0
     lqops: oplist=CABPQSH nops=C:30 A:435 B:465 P:861 Q:903 S:42 H:1 
     rqops: oplist=CABPQSH nops=C:38 A:703 B:741 P:561 Q:595 S:34 H:1 
     c1qops: oplist=CABPQSH nops=C:2 A:1 B:3 P:2415 Q:2485 S:70 H:1 
     c2qops: oplist=CABPQSH nops=C:2 A:1 B:3 P:2415 Q:2485 S:70 H:1 
    qbond info:
     qbond: ql nsym=14 dimAll=1000
     qbond: qr nsym=17 dimAll=1000
     qbond: qc1 nsym=4 dimAll=4
     qbond: qc2 nsym=4 dimAll=4
    sym_state=(54,0) dim(localCI)=1103160
    twodot_Hx_functors: size=1097 CS:32 SC:40 AP:496 BQ:528
    ctns::twodot_guess |c2r>
    ctns::pdvdsonSolver_nkr::solve_iter is_complex=0 size=1
    settings: ndim=1103160 neig=1 nbuff=4 maxcycle=6
              damping=0.1 crit_v=1.00e-04 crit_e=1.00e-12 crit_indp=1.00e-12
    iter   ieig        eigenvalue        ediff      rnorm   nsub  nmvp   time/s    tav/s
        1   0 -    -327.222794442929  -1.33e+03   7.31e-03    1     1   1.67e+01  1.67e+01
        2   0 -    -327.222830750463  -3.63e-05   1.38e-03    2     2   3.34e+01  1.67e+01
        3   0 -    -327.222832134107  -1.38e-06   4.88e-04    2     3   5.00e+01  1.67e+01
        4   0 -    -327.222832322393  -1.88e-07   2.40e-04    2     4   6.67e+01  1.67e+01
        5   0 -    -327.222832371250  -4.89e-08   1.42e-04    2     5   8.34e+01  1.67e+01
        6   0 +    -327.222832389603  -1.84e-08   9.59e-05    2     6   1.00e+02  1.67e+01
     optimized energies: isweep=5 dots=2 ibond=51 e[0]=-327.22283239
    ----- oper_timing -----
     user=3.53e+03 S system=4.07e+01 S wall=1.00e+02 S ratio=3.57e+01
     opxwf=3.21e+03 S per=9.00e+01
      opC: t=1.25e+01 S per=3.90e-01 n=864 tav=1.45e-02 S
      opA: t=4.97e+01 S per=1.55e+00 n=5952 tav=8.36e-03 S
      opB: t=7.13e+01 S per=2.22e+00 n=6336 tav=1.13e-02 S
      opH: t=2.61e+01 S per=8.14e-01 n=12 tav=2.18e+00 S
      opS: t=1.54e+03 S per=4.78e+01 n=864 tav=1.78e+00 S
      opP: t=5.54e+02 S per=1.72e+01 n=5952 tav=9.31e-02 S
      opQ: t=9.63e+02 S per=3.00e+01 n=6336 tav=1.52e-01 S
     totHx=9.98e+01 S Init=6.06e-01 S Calc=9.91e+01 S Finl=7.00e-02 S

 1. 公式预先计算
    -------------------------
    TODOs: Tensor operations
    -------------------------
     a. allocate temporary work space!
     b. in place operation:
        opwf += oper_kernel_OOwf(superblock,site,op1c,op2S,1); 
     sweep_twodot_ham.h:
        // Apq*Ppq
        qt3n = oper_compxwf_opP("cr",wf2,c2qops,rqops,isym,ifkr,int2e,int1e,index);
        qt3n = qt3n.merge_cr().split_lc(wf.qrow,wf.qmid);
        auto Hwf1 = wt*oper_normxwf_opA("lc",qt3n,lqops,c1qops,ifkr,iformula,index);
     oper_normxwf.h:
     oper_compxwf.h:
        qtensor3<Tm> opwf(site.sym, site.qmid, site.qrow, site.qcol, site.dir); -> working space
        opwf += oper_kernel_OOwf(superblock,site,op1c,op2S,1); -> inplace
        opwf += wt*oper_kernel_OOwf(superblock,site,op1_A,op2_A,0);
     oper_kernel.h:
        oper_kernel_OIwf
        oper_kernel_IOwf
        oper_kernel_OOwf
     c. remove T() and H() in contract_qt_qt...

 2. 提升并行效率

 3. 异构计算 -> further accelerate contract_qt4_qt2?

Comments:
 1. direct operating wf4 in sweep_twodot_sigma.h without temporary stensor3
 2. probably change to shared_ptr to share data instead of raw pointer & own?

